// Package forecastts provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package forecastts

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for CoverageJSONType.
const (
	Coverage CoverageJSONType = "Coverage"
)

// Defines values for DomainDomainType.
const (
	PointSeries DomainDomainType = "PointSeries"
)

// Defines values for DomainType.
const (
	DomainTypeDomain DomainType = "Domain"
)

// Defines values for EdrFeatureCollectionGeoJSONType.
const (
	FeatureCollection EdrFeatureCollectionGeoJSONType = "FeatureCollection"
)

// Defines values for FeatureGeoJSONType.
const (
	Feature FeatureGeoJSONType = "Feature"
)

// Defines values for GeometrycollectionGeoJSONType.
const (
	GeometryCollection GeometrycollectionGeoJSONType = "GeometryCollection"
)

// Defines values for ItemsDataQueryQueryType.
const (
	Items ItemsDataQueryQueryType = "items"
)

// Defines values for LinestringGeoJSONType.
const (
	LineString   LinestringGeoJSONType = "LineString"
	LineStringM  LinestringGeoJSONType = "LineStringM"
	LineStringZ  LinestringGeoJSONType = "LineStringZ"
	LineStringZM LinestringGeoJSONType = "LineStringZM"
)

// Defines values for MultilinestringGeoJSONType.
const (
	MultiLineString MultilinestringGeoJSONType = "MultiLineString"
)

// Defines values for MultipointGeoJSONType.
const (
	MultiPoint MultipointGeoJSONType = "MultiPoint"
)

// Defines values for MultipolygonGeoJSONType.
const (
	MultiPolygon MultipolygonGeoJSONType = "MultiPolygon"
)

// Defines values for NdArrayType.
const (
	NdArrayTypeNdArray NdArrayType = "NdArray"
)

// Defines values for ParameterType.
const (
	ParameterTypeParameter ParameterType = "Parameter"
)

// Defines values for ParameterNamesDataType.
const (
	Float   ParameterNamesDataType = "float"
	Integer ParameterNamesDataType = "integer"
	String  ParameterNamesDataType = "string"
)

// Defines values for ParameterNamesType.
const (
	ParameterNamesTypeParameter ParameterNamesType = "Parameter"
)

// Defines values for PointGeoJSONType.
const (
	Point PointGeoJSONType = "Point"
)

// Defines values for PolygonGeoJSONType.
const (
	Polygon PolygonGeoJSONType = "Polygon"
)

// Defines values for ReferenceSystemType.
const (
	GeographicCRS ReferenceSystemType = "GeographicCRS"
	ProjectedCRS  ReferenceSystemType = "ProjectedCRS"
	TemporalRS    ReferenceSystemType = "TemporalRS"
	VerticalCRS   ReferenceSystemType = "VerticalCRS"
)

// DataQuery Property to contain any extra metadata information that is specific to an individual data query
type DataQuery struct {
	// CrsDetails List of key/value definitions for the CRS's supported by the Position query.  The key is the query parameter and the value is the Well Known Text description
	CrsDetails []CrsObject `json:"crs_details"`

	// DefaultOutputFormat default output format for the Position query
	DefaultOutputFormat string `json:"default_output_format"`

	// Description description of the query
	Description string `json:"description"`

	// OutputFormats list of output formats supported by the Position query
	OutputFormats []string `json:"output_formats"`

	// Title title of the query
	Title string `json:"title"`
}

// Collection defines model for collection.
type Collection struct {
	// Crs list of the coordinate reference systems the collection results can support
	Crs []string `json:"crs"`

	// DataQueries Detailed information relevant to individual query types
	DataQueries struct {
		Items *struct {
			Link *ItemsLink `json:"link,omitempty"`
		} `json:"items,omitempty"`
		Locations *struct {
			Link *LocationsLink `json:"link,omitempty"`
		} `json:"locations,omitempty"`
		Position struct {
			Link *PositionLink `json:"link,omitempty"`
		} `json:"position"`
	} `json:"data_queries"`

	// Description description of the collection
	Description *string `json:"description,omitempty"`

	// Extent The extent of the information in the collection. In the Core only spatial and temporal
	// extents are specified. Extensions may add additional members to represent other
	// extents, for example, thermal or pressure ranges.
	Extent Extent `json:"extent"`

	// Id id of the collection
	Id string `json:"id"`

	// Keywords List of keywords which help to describe the collection
	Keywords *[]string `json:"keywords,omitempty"`
	Links    []Link    `json:"links"`

	// OutputFormats list of formats the results can be presented in
	OutputFormats []string `json:"output_formats"`

	// ParameterNames list of the data parameters available in the collection
	ParameterNames map[string]ParameterNames `json:"parameter_names"`

	// Title title of the collection
	Title *string `json:"title,omitempty"`
}

// CollectionUnit definition of unit
type CollectionUnit struct {
	// Label Name of the unit
	Label  string               `json:"label"`
	Symbol CollectionUnitSymbol `json:"symbol"`
}

// CollectionUnitSymbol defines model for collectionUnitSymbol.
type CollectionUnitSymbol struct {
	// Description A text description of the symbol
	Description *string `json:"description,omitempty"`

	// Title Symbol name
	Title *string `json:"title,omitempty"`

	// Type uri to detailed desxcription of the units
	Type *string `json:"type,omitempty"`

	// Value representation of the units symbol
	Value *string `json:"value,omitempty"`
}

// Collections defines model for collections.
type Collections struct {
	Collections []Collection `json:"collections"`
	Links       []Link       `json:"links"`
}

// ConfClasses defines model for confClasses.
type ConfClasses struct {
	ConformsTo []string `json:"conformsTo"`
}

// CoverageJSON A geospatial coverage interchange format based on JavaScript Object Notation (JSON)
type CoverageJSON struct {
	// Domain A Domain, which defines a set of positions and their extent in one or more referencing systems
	Domain     *Domain               `json:"domain,omitempty"`
	Parameters *map[string]Parameter `json:"parameters,omitempty"`
	Ranges     *map[string]NdArray   `json:"ranges,omitempty"`

	// Type Coverage domain type
	Type CoverageJSONType `json:"type"`
}

// CoverageJSONType Coverage domain type
type CoverageJSONType string

// CrsObject defines model for crsObject.
type CrsObject struct {
	// Crs name of the coordinate reference system, used as the value in the crs query parameter to define the required output CRS
	Crs string `json:"crs"`

	// Wkt Well Known text description of the coordinate reference system
	Wkt string `json:"wkt"`
}

// Domain A Domain, which defines a set of positions and their extent in one or more referencing systems
type Domain struct {
	// Axes Grid domain: x and y are required, z and t optional
	Axes struct {
		// T Simple axis with string values (e.g. time strings)
		T *StringValuesAxis `json:"t,omitempty"`

		// X Custom, simplified values axies for forecast timeseries profile.
		X MettsnumericValuesAxis `json:"x"`

		// Y Custom, simplified values axies for forecast timeseries profile.
		Y MettsnumericValuesAxis `json:"y"`

		// Z Custom, simplified values axies for forecast timeseries profile.
		Z *MettsnumericValuesAxis `json:"z,omitempty"`
	} `json:"axes"`
	DomainType  *DomainDomainType            `json:"domainType,omitempty"`
	Referencing *[]ReferenceSystemConnection `json:"referencing,omitempty"`
	Type        DomainType                   `json:"type"`
}

// DomainDomainType defines model for Domain.DomainType.
type DomainDomainType string

// DomainType defines model for Domain.Type.
type DomainType string

// EdrFeatureCollectionGeoJSON defines model for edrFeatureCollectionGeoJSON.
type EdrFeatureCollectionGeoJSON struct {
	Features []FeatureGeoJSON `json:"features"`
	Links    *[]Link          `json:"links,omitempty"`

	// NumberMatched The number of features of the feature type that match the selection
	// parameters like `bbox`.
	NumberMatched *NumberMatched `json:"numberMatched,omitempty"`

	// NumberReturned The number of features in the feature collection.
	//
	// A server may omit this information in a response, if the information
	// about the number of features is not known or difficult to compute.
	//
	// If the value is provided, the value shall be identical to the number
	// of items in the "features" array.
	NumberReturned *NumberReturned `json:"numberReturned,omitempty"`

	// Parameters list of the data parameters available in the collection
	Parameters *[]Parameter `json:"parameters,omitempty"`

	// TimeStamp This property indicates the time and date when the response was generated.
	TimeStamp *time.Time                      `json:"timeStamp,omitempty"`
	Type      EdrFeatureCollectionGeoJSONType `json:"type"`
}

// EdrFeatureCollectionGeoJSONType defines model for EdrFeatureCollectionGeoJSON.Type.
type EdrFeatureCollectionGeoJSONType string

// EdrProperties Properties to describe existing EDR features -- may be real-world or virtual sampling features.
type EdrProperties struct {
	// Datetime Either a date-time or a period string that adheres to RFC 3339. Indicates the time instant or period for which data are available from the EDR feature.
	Datetime string `json:"datetime"`

	// Edrqueryendpoint A URI identifying the query end point. May identify a specific location.
	Edrqueryendpoint string `json:"edrqueryendpoint"`

	// Label A label such as a site name or other text to use on a link.
	Label string `json:"label"`

	// ParameterName Unique IDs of available parameters, this is the value used for querying the data and corresponds to an ID in the parameter metadata of the collection.
	ParameterName []string `json:"parameter-name"`
}

// Exception defines model for exception.
type Exception struct {
	Code        string  `json:"code"`
	Description *string `json:"description,omitempty"`
}

// Extent The extent of the information in the collection. In the Core only spatial and temporal
// extents are specified. Extensions may add additional members to represent other
// extents, for example, thermal or pressure ranges.
type Extent struct {
	// Spatial The spatial extent of the information in the collection.
	Spatial *struct {
		// Bbox One or more bounding boxes that describe the spatial extent of the dataset.
		// In the Core only a single bounding box is supported. Extensions may support
		// additional areas. If multiple areas are provided, the union of the bounding
		// boxes describes the spatial extent.
		Bbox []Extent_Spatial_Bbox_Item `json:"bbox"`

		// Crs Coordinate reference system of the coordinates in the spatial extent
		// (property `bbox`). The default reference system is WGS 84 longitude/latitude.
		// In the Core this is the only supported coordinate reference system.
		// Extensions may support additional coordinate reference systems
		Crs string `json:"crs"`

		// Name Name of the vertical coordinate reference system
		Name *string `json:"name,omitempty"`
	} `json:"spatial,omitempty"`

	// Temporal The temporal extent of the information in the collection.
	Temporal *struct {
		// Interval RFC3339 compliant Date and Time
		Interval [][]time.Time `json:"interval"`

		// Name Name of the temporal coordinate reference system
		Name *string `json:"name,omitempty"`

		// Trs Coordinate reference system of the coordinates in the temporal extent
		// (property `interval`). The default reference system is the Gregorian calendar.
		// In the Core this is the only supported temporal coordinate reference system.
		// Extensions may support additional temporal coordinate reference systems
		Trs string `json:"trs"`

		// Values Provides information about the time intervals available in the collection
		// as ISO8601 compliant dates, either as a time range specified
		// as start time / end time  (e.g. 2017-11-14T09:00Z/2017-11-14T21:00Z)  or
		// as number of repetitions / start time / interval (e.g. R4/2017-11-14T21:00Z/PT3H)
		// or a list of time values (e.g.
		// 2017-11-14T09:00Z,2017-11-14T12:00Z,2017-11-14T15:00Z,2017-11-14T18:00Z,2017-11-14T21:00Z)
		Values *[]time.Time `json:"values,omitempty"`
	} `json:"temporal,omitempty"`

	// Vertical The vertical extent of the information in the collection.
	Vertical *struct {
		// Interval In the Core only a single time interval is supported. Extensions may support
		// multiple intervals. If multiple intervals are provided, the union of the
		// intervals describes the vertical extent.
		Interval [][]string `json:"interval"`

		// Name Name of the vertical coordinate reference system
		Name *string `json:"name,omitempty"`

		// Values Vertical level intervals that data in the collection is available at
		// these can be defined as follows:
		// min level / max level (e.g. "2/100") or
		// as number of repetitions / start level / interval (e.g."R5/100/50")
		// or a list of vertical levels (e.g. "2",10,"80","100"}
		// The value `null` is supported and indicates an open vertical interval.
		Values *[]string `json:"values,omitempty"`

		// Vrs Coordinate reference system of the coordinates in the vertical extent
		// (property `interval`).
		Vrs string `json:"vrs"`
	} `json:"vertical,omitempty"`
}

// ExtentSpatialBbox0 defines model for .
type ExtentSpatialBbox0 = []float32

// ExtentSpatialBbox1 defines model for .
type ExtentSpatialBbox1 = []float32

// Extent_Spatial_Bbox_Item Each bounding box is provided as four or six numbers, depending on
// whether the coordinate reference system includes a vertical axis
// (height or depth):
//
// * Lower left corner, coordinate axis 1
// * Lower left corner, coordinate axis 2
// * Minimum value, coordinate axis 3 (optional)
// * Upper right corner, coordinate axis 1
// * Upper right corner, coordinate axis 2
// * Maximum value, coordinate axis 3 (optional)
//
// The coordinate reference system of the values is WGS 84 longitude/latitude
// (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate
// reference system is specified in `crs`.
//
// For WGS 84 longitude/latitude the values are in most cases the sequence of
// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
// However, in cases where the box spans the antimeridian the first value
// (west-most box edge) is larger than the third value (east-most box edge).
//
// If the vertical axis is included, the third and the sixth number are
// the bottom and the top of the 3-dimensional bounding box.
//
// If a feature has multiple spatial geometry properties, it is the decision of the
// server whether only a single spatial geometry property is used to determine
// the extent or all relevant geometries.
type Extent_Spatial_Bbox_Item struct {
	union json.RawMessage
}

// FeatureGeoJSON defines model for featureGeoJSON.
type FeatureGeoJSON struct {
	Geometry FeatureGeoJSON_Geometry `json:"geometry"`
	Id       *FeatureGeoJSON_Id      `json:"id,omitempty"`
	Links    *[]Link                 `json:"links,omitempty"`

	// Properties Properties to describe existing EDR features -- may be real-world or virtual sampling features.
	Properties EdrProperties      `json:"properties"`
	Type       FeatureGeoJSONType `json:"type"`
}

// FeatureGeoJSON_Geometry defines model for FeatureGeoJSON.Geometry.
type FeatureGeoJSON_Geometry struct {
	union json.RawMessage
}

// FeatureGeoJSONId0 defines model for .
type FeatureGeoJSONId0 = string

// FeatureGeoJSONId1 defines model for .
type FeatureGeoJSONId1 = int

// FeatureGeoJSON_Id defines model for FeatureGeoJSON.Id.
type FeatureGeoJSON_Id struct {
	union json.RawMessage
}

// FeatureGeoJSONType defines model for FeatureGeoJSON.Type.
type FeatureGeoJSONType string

// GeoJSONunit The units of measure
type GeoJSONunit struct {
	Id *string `json:"id,omitempty"`

	// Label Object representing an internationalised string.
	Label  I18n `json:"label"`
	Symbol *struct {
		Type  string `json:"type"`
		Value string `json:"value"`
	} `json:"symbol,omitempty"`
}

// GeometrycollectionGeoJSON defines model for geometrycollectionGeoJSON.
type GeometrycollectionGeoJSON struct {
	Geometries []GeometrycollectionGeoJSON_Geometries_Item `json:"geometries"`
	Type       GeometrycollectionGeoJSONType               `json:"type"`
}

// GeometrycollectionGeoJSON_Geometries_Item defines model for geometrycollectionGeoJSON.geometries.Item.
type GeometrycollectionGeoJSON_Geometries_Item struct {
	union json.RawMessage
}

// GeometrycollectionGeoJSONType defines model for GeometrycollectionGeoJSON.Type.
type GeometrycollectionGeoJSONType string

// I18n Object representing an internationalised string.
type I18n map[string]string

// Instances defines model for instances.
type Instances struct {
	Instances []Collection `json:"instances"`
	Links     []Link       `json:"links"`
}

// ItemsDataQuery Property to contain any extra metadata information that is specific to an individual data queries
type ItemsDataQuery struct {
	// Description description of the query
	Description *string `json:"description,omitempty"`

	// QueryType Type of EDR query
	QueryType *ItemsDataQueryQueryType `json:"query_type,omitempty"`

	// Title title of the query
	Title *string `json:"title,omitempty"`
}

// ItemsDataQueryQueryType Type of EDR query
type ItemsDataQueryQueryType string

// ItemsLink defines model for itemsLink.
type ItemsLink = Link

// LandingPage defines model for landingPage.
type LandingPage struct {
	Contact *struct {
		Address *string `json:"address,omitempty"`
		City    *string `json:"city,omitempty"`
		Country *string `json:"country,omitempty"`

		// Email Email address of service provider
		Email *string `json:"email,omitempty"`

		// Fax Fax number of service provider
		Fax          *string `json:"fax,omitempty"`
		Hours        *string `json:"hours,omitempty"`
		Instructions *string `json:"instructions,omitempty"`

		// Phone Phone number of service provider
		Phone           *string `json:"phone,omitempty"`
		PostalCode      *string `json:"postalCode,omitempty"`
		Stateorprovince *string `json:"stateorprovince,omitempty"`
	} `json:"contact,omitempty"`
	Description *string   `json:"description,omitempty"`
	Keywords    *[]string `json:"keywords,omitempty"`
	Links       []Link    `json:"links"`
	Provider    *struct {
		// Name Name of organization providing the service
		Name *string `json:"name,omitempty"`

		// Url Link to service providers website
		Url *string `json:"url,omitempty"`
	} `json:"provider,omitempty"`
	Title *string `json:"title,omitempty"`
}

// LinestringGeoJSON defines model for linestringGeoJSON.
type LinestringGeoJSON struct {
	Coordinates [][][]float32         `json:"coordinates"`
	Type        LinestringGeoJSONType `json:"type"`
}

// LinestringGeoJSONType defines model for LinestringGeoJSON.Type.
type LinestringGeoJSONType string

// Link defines model for link.
type Link struct {
	Href     string  `json:"href"`
	Hreflang *string `json:"hreflang,omitempty"`
	Length   *int    `json:"length,omitempty"`
	Rel      string  `json:"rel"`

	// Templated defines if the link href value is a template with values requiring replacement
	Templated *bool   `json:"templated,omitempty"`
	Title     *string `json:"title,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// LocationsDataQuery Property to contain any extra metadata information that is specific to an individual data query
type LocationsDataQuery = DataQuery

// LocationsLink defines model for locationsLink.
type LocationsLink = Link

// MettsnumericValuesAxis Custom, simplified values axies for forecast timeseries profile.
type MettsnumericValuesAxis struct {
	Values *[]float32 `json:"values,omitempty"`
}

// MultilinestringGeoJSON defines model for multilinestringGeoJSON.
type MultilinestringGeoJSON struct {
	Coordinates [][][]float32              `json:"coordinates"`
	Type        MultilinestringGeoJSONType `json:"type"`
}

// MultilinestringGeoJSONType defines model for MultilinestringGeoJSON.Type.
type MultilinestringGeoJSONType string

// MultipointGeoJSON defines model for multipointGeoJSON.
type MultipointGeoJSON struct {
	Coordinates [][]float32           `json:"coordinates"`
	Type        MultipointGeoJSONType `json:"type"`
}

// MultipointGeoJSONType defines model for MultipointGeoJSON.Type.
type MultipointGeoJSONType string

// MultipolygonGeoJSON defines model for multipolygonGeoJSON.
type MultipolygonGeoJSON struct {
	Coordinates [][][][]float32         `json:"coordinates"`
	Type        MultipolygonGeoJSONType `json:"type"`
}

// MultipolygonGeoJSONType defines model for MultipolygonGeoJSON.Type.
type MultipolygonGeoJSONType string

// NdArray Object representing a multidimensional (>= 0D) array with named axes, encoded as a flat one-dimensional array in row-major order
type NdArray struct {
	AxisNames []string    `json:"axisNames"`
	DataType  interface{} `json:"dataType"`
	Shape     []float32   `json:"shape"`
	Type      NdArrayType `json:"type"`
	Values    []float32   `json:"values"`
}

// NdArrayType defines model for NdArray.Type.
type NdArrayType string

// NumberMatched The number of features of the feature type that match the selection
// parameters like `bbox`.
type NumberMatched = int

// NumberReturned The number of features in the feature collection.
//
// A server may omit this information in a response, if the information
// about the number of features is not known or difficult to compute.
//
// If the value is provided, the value shall be identical to the number
// of items in the "features" array.
type NumberReturned = int

// ObservedProperty A definition of the quantity being measured.
type ObservedProperty struct {
	Categories *[]struct {
		// Description Object representing an internationalised string.
		Description *I18n  `json:"description,omitempty"`
		Id          string `json:"id"`

		// Label Object representing an internationalised string.
		Label I18n `json:"label"`
	} `json:"categories,omitempty"`

	// Description Object representing an internationalised string.
	Description *I18n   `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Label Object representing an internationalised string.
	Label I18n `json:"label"`
}

// ObservedPropertyCollection Description of the property
type ObservedPropertyCollection struct {
	Categories *[]struct {
		Description *ObservedPropertyCollection_Categories_Description `json:"description,omitempty"`

		// Id URI linking to an external registry which contains the definitive definition of
		// the observed property
		Id    string                                      `json:"id"`
		Label ObservedPropertyCollection_Categories_Label `json:"label"`
	} `json:"categories,omitempty"`
	Description *string `json:"description,omitempty"`

	// Id URI linking to an external registry which contains the definitive definition of
	// the observed property
	Id    *string                          `json:"id,omitempty"`
	Label ObservedPropertyCollection_Label `json:"label"`
}

// ObservedPropertyCollectionCategoriesDescription0 defines model for .
type ObservedPropertyCollectionCategoriesDescription0 = string

// ObservedPropertyCollectionCategoriesDescription1 defines model for .
type ObservedPropertyCollectionCategoriesDescription1 struct {
	En string `json:"en"`
}

// ObservedPropertyCollection_Categories_Description defines model for ObservedPropertyCollection.Categories.Description.
type ObservedPropertyCollection_Categories_Description struct {
	union json.RawMessage
}

// ObservedPropertyCollectionCategoriesLabel0 defines model for .
type ObservedPropertyCollectionCategoriesLabel0 = string

// ObservedPropertyCollectionCategoriesLabel1 defines model for .
type ObservedPropertyCollectionCategoriesLabel1 = map[string]interface{}

// ObservedPropertyCollection_Categories_Label defines model for ObservedPropertyCollection.Categories.Label.
type ObservedPropertyCollection_Categories_Label struct {
	union json.RawMessage
}

// ObservedPropertyCollectionLabel0 defines model for .
type ObservedPropertyCollectionLabel0 = string

// ObservedPropertyCollectionLabel1 defines model for .
type ObservedPropertyCollectionLabel1 = map[string]interface{}

// ObservedPropertyCollection_Label defines model for ObservedPropertyCollection.Label.
type ObservedPropertyCollection_Label struct {
	union json.RawMessage
}

// Parameter Represents metadata about the values of the coverage
type Parameter struct {
	// CategoryEncoding Maps IDs of categories in the observedProperty to range values
	CategoryEncoding *map[string]Parameter_CategoryEncoding_AdditionalProperties `json:"categoryEncoding,omitempty"`

	// Description Object representing an internationalised string.
	Description *I18n   `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`

	// ObservedProperty A definition of the quantity being measured.
	ObservedProperty ObservedProperty `json:"observedProperty"`

	// Type Type of the parameter object, shall be "Parameter"
	Type ParameterType `json:"type"`

	// Unit The units of measure
	Unit *GeoJSONunit `json:"unit,omitempty"`
}

// ParameterCategoryEncoding0 defines model for .
type ParameterCategoryEncoding0 = int

// ParameterCategoryEncoding1 defines model for .
type ParameterCategoryEncoding1 = []int

// Parameter_CategoryEncoding_AdditionalProperties defines model for parameter.categoryEncoding.AdditionalProperties.
type Parameter_CategoryEncoding_AdditionalProperties struct {
	union json.RawMessage
}

// ParameterType Type of the parameter object, shall be "Parameter"
type ParameterType string

// ParameterNames Definition of data parameter
type ParameterNames struct {
	CategoryEncoding *map[string]ParameterNames_CategoryEncoding_AdditionalProperties `json:"categoryEncoding,omitempty"`

	// DataType Data type of returned parameter
	DataType    *ParameterNamesDataType `json:"data-type,omitempty"`
	Description *string                 `json:"description,omitempty"`

	// Extent The extent of the information in the collection. In the Core only spatial and temporal
	// extents are specified. Extensions may add additional members to represent other
	// extents, for example, thermal or pressure ranges.
	Extent *Extent `json:"extent,omitempty"`

	// Id Unique ID of the parameter, this is the value used for querying the data
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`

	// MeasurementType Approach to calculating the data values
	MeasurementType *struct {
		// Duration The time duration that the value was calculated for as an RFC3339 duration value.  If the method value is instantaneous this value is not required.
		Duration *string `json:"duration,omitempty"`
		Method   string  `json:"method"`
	} `json:"measurementType,omitempty"`

	// ObservedProperty Description of the property
	ObservedProperty ObservedPropertyCollection `json:"observedProperty"`

	// Type type
	Type ParameterNamesType `json:"type"`

	// Unit definition of unit
	Unit *CollectionUnit `json:"unit,omitempty"`
}

// ParameterNamesCategoryEncoding0 defines model for .
type ParameterNamesCategoryEncoding0 = int

// ParameterNamesCategoryEncoding1 defines model for .
type ParameterNamesCategoryEncoding1 = []int

// ParameterNames_CategoryEncoding_AdditionalProperties defines model for parameterNames.categoryEncoding.AdditionalProperties.
type ParameterNames_CategoryEncoding_AdditionalProperties struct {
	union json.RawMessage
}

// ParameterNamesDataType Data type of returned parameter
type ParameterNamesDataType string

// ParameterNamesType type
type ParameterNamesType string

// PointGeoJSON defines model for pointGeoJSON.
type PointGeoJSON struct {
	Coordinates []float32        `json:"coordinates"`
	Type        PointGeoJSONType `json:"type"`
}

// PointGeoJSONType defines model for PointGeoJSON.Type.
type PointGeoJSONType string

// PolygonGeoJSON defines model for polygonGeoJSON.
type PolygonGeoJSON struct {
	Coordinates [][][]float32      `json:"coordinates"`
	Type        PolygonGeoJSONType `json:"type"`
}

// PolygonGeoJSONType defines model for PolygonGeoJSON.Type.
type PolygonGeoJSONType string

// PositionDataQuery Property to contain any extra metadata information that is specific to an individual data query
type PositionDataQuery = DataQuery

// PositionLink defines model for positionLink.
type PositionLink struct {
	Href     string  `json:"href"`
	Hreflang *string `json:"hreflang,omitempty"`
	Length   *int    `json:"length,omitempty"`
	Rel      string  `json:"rel"`

	// Templated defines if the link href value is a template with values requiring replacement
	Templated *bool              `json:"templated,omitempty"`
	Title     *string            `json:"title,omitempty"`
	Type      *string            `json:"type,omitempty"`
	Variables *PositionDataQuery `json:"variables,omitempty"`
}

// ReferenceSystem defines model for referenceSystem.
type ReferenceSystem struct {
	Type  ReferenceSystemType `json:"type"`
	union json.RawMessage
}

// ReferenceSystemType defines model for ReferenceSystem.Type.
type ReferenceSystemType string

// ReferenceSystem0 Temporal reference system
type ReferenceSystem0 struct {
	Calendar  string  `json:"calendar"`
	TimeScale *string `json:"timeScale,omitempty"`
}

// ReferenceSystem1 Geographic / Projected / Vertical Coordinate Reference Systems
type ReferenceSystem1 struct {
	// Description Object representing an internationalised string.
	Description I18n    `json:"description"`
	Id          *string `json:"id,omitempty"`
}

// ReferenceSystemConnection Reference System Connection object: connects coordinates to reference systems
type ReferenceSystemConnection struct {
	Coordinates []string        `json:"coordinates"`
	System      ReferenceSystem `json:"system"`
}

// StringValuesAxis defines model for stringValuesAxis.
type StringValuesAxis struct {
	Bounds      *interface{} `json:"bounds,omitempty"`
	Coordinates *[]string    `json:"coordinates,omitempty"`
	DataType    *string      `json:"dataType,omitempty"`
	Values      interface{}  `json:"values"`
}

// ValuesAxisBase Base schema for values-based axis schemas
type ValuesAxisBase struct {
	// Bounds Optional axis bounds. Shall be twice as long (and same data type) as "values"
	Bounds      *[]interface{} `json:"bounds,omitempty"`
	Coordinates *[]string      `json:"coordinates,omitempty"`
	DataType    *string        `json:"dataType,omitempty"`
	Values      []interface{}  `json:"values"`
}

// Bbox defines model for bbox.
type Bbox struct {
	union json.RawMessage
}

// CollectionId defines model for collectionId.
type CollectionId = string

// Crs defines model for crs.
type Crs = string

// Datetime defines model for datetime.
type Datetime = string

// F defines model for f.
type F = string

// InstanceId defines model for instanceId.
type InstanceId = string

// ParameterName defines model for parameter-name.
type ParameterName = string

// PositionCoords defines model for positionCoords.
type PositionCoords = string

// Z defines model for z.
type Z = string

// N200ApplicationGeoPlusJSON defines model for 200.
type N200ApplicationGeoPlusJSON = EdrFeatureCollectionGeoJSON

// N200ApplicationVndCovPlusJSON A geospatial coverage interchange format based on JavaScript Object Notation (JSON)
type N200ApplicationVndCovPlusJSON = CoverageJSON

// N400 defines model for 400.
type N400 = Exception

// N404 defines model for 404.
type N404 = Exception

// N413 defines model for 413.
type N413 = Exception

// Conformance defines model for conformance.
type Conformance = ConfClasses

// GetLandingPageParams defines parameters for GetLandingPage.
type GetLandingPageParams struct {
	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// Bbox Only features that have a geometry that intersects the bounding box are selected.
	// The bounding box is provided as four or six numbers, depending on whether the
	// coordinate reference system includes a vertical axis (height or depth):
	// * Lower left corner, coordinate axis 1
	// * Lower left corner, coordinate axis 2
	// * Minimum value, coordinate axis 3 (optional)
	// * Upper right corner, coordinate axis 1
	// * Upper right corner, coordinate axis 2
	// * Maximum value, coordinate axis 3 (optional)
	// The coordinate reference system of the values is WGS 84 longitude/latitude
	// (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate
	// reference system is specified in the parameter `bbox-crs`.
	// For WGS 84 longitude/latitude the values are in most cases the sequence of
	// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
	// However, in cases where the box spans the antimeridian the first value
	// (west-most box edge) is larger than the third value (east-most box edge).
	// If the vertical axis is included, the third and the sixth number are the
	// bottom and the top of the 3-dimensional bounding box.
	// If a feature has multiple spatial geometry properties, it is the decision of the
	// server whether only a single spatial geometry property is used to determine
	// the extent or all relevant geometries.
	Bbox *Bbox `form:"bbox,omitempty" json:"bbox,omitempty"`

	// Datetime Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).
	// Examples:
	// * A date-time: "2018-02-12T23:20:50Z" * A bounded interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z" * Half-bounded intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
	// Only resources that have a temporal property that intersects the value of `datetime` are selected.
	// If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
	Datetime *Datetime `form:"datetime,omitempty" json:"datetime,omitempty"`

	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// ListCollectionsParamsBbox0 defines parameters for ListCollections.
type ListCollectionsParamsBbox0 = []float32

// ListCollectionsParamsBbox1 defines parameters for ListCollections.
type ListCollectionsParamsBbox1 = []float32

// GetQueriesParams defines parameters for GetQueries.
type GetQueriesParams struct {
	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// GetCollectionInstancesParams defines parameters for GetCollectionInstances.
type GetCollectionInstancesParams struct {
	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// GetInstanceDataForPointParams defines parameters for GetInstanceDataForPoint.
type GetInstanceDataForPointParams struct {
	// Coords location(s) to return data for, the coordinates are defined by a Well Known Text
	// (wkt) string. to retrieve a single location :
	//
	// POINT(x y) i.e. POINT(0 51.48) for Greenwich, London
	//
	// And for a list of locations
	//
	// MULTIPOINT((x y),(x1 y1),(x2 y2),(x3 y3))
	//
	// i.e.
	// MULTIPOINT((38.9 -77),(48.85 2.35),(39.92 116.38),(-35.29 149.1),(51.5 -0.1))
	//
	// see http://portal.opengeospatial.org/files/?artifact_id=25355 and
	// https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry
	//
	// the coordinate values will depend on the CRS parameter, if this is not defined
	// the values will be assumed to WGS84 values (i.e x=longitude and y=latitude)
	Coords PositionCoords `form:"coords" json:"coords"`

	// Z Define the vertical level to return data from
	// i.e. z=level
	//
	// for instance if the 850hPa pressure level is being queried
	//
	// z=850
	//
	// or a range to return data for all levels between and including 2 defined levels
	// i.e. z=minimum value/maximum value
	//
	// for instance if all values between and including 10m and 100m
	//
	// z=10/100
	//
	// finally a list of height values can be specified
	// i.e. z=value1,value2,value3
	//
	// for instance if values at 2m, 10m and 80m are required
	//
	// z=2,10,80
	//
	// An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start
	// and the amount to increment the height by is defined at the end
	//
	// i.e. z=Rn/min height/height interval
	//
	// so if the request was for 20 height levels 50m apart starting at 100m:
	//
	// z=R20/100/50
	//
	// When not specified data from all available heights SHOULD be returned
	Z *Z `form:"z,omitempty" json:"z,omitempty"`

	// Datetime Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).
	// Examples:
	// * A date-time: "2018-02-12T23:20:50Z" * A bounded interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z" * Half-bounded intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
	// Only resources that have a temporal property that intersects the value of `datetime` are selected.
	// If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
	Datetime *Datetime `form:"datetime,omitempty" json:"datetime,omitempty"`

	// ParameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
	ParameterName *ParameterName `form:"parameter-name,omitempty" json:"parameter-name,omitempty"`

	// Crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
	Crs *Crs `form:"crs,omitempty" json:"crs,omitempty"`

	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// GetDataForPointParams defines parameters for GetDataForPoint.
type GetDataForPointParams struct {
	// Coords location(s) to return data for, the coordinates are defined by a Well Known Text
	// (wkt) string. to retrieve a single location :
	//
	// POINT(x y) i.e. POINT(0 51.48) for Greenwich, London
	//
	// And for a list of locations
	//
	// MULTIPOINT((x y),(x1 y1),(x2 y2),(x3 y3))
	//
	// i.e.
	// MULTIPOINT((38.9 -77),(48.85 2.35),(39.92 116.38),(-35.29 149.1),(51.5 -0.1))
	//
	// see http://portal.opengeospatial.org/files/?artifact_id=25355 and
	// https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry
	//
	// the coordinate values will depend on the CRS parameter, if this is not defined
	// the values will be assumed to WGS84 values (i.e x=longitude and y=latitude)
	Coords PositionCoords `form:"coords" json:"coords"`

	// Z Define the vertical level to return data from
	// i.e. z=level
	//
	// for instance if the 850hPa pressure level is being queried
	//
	// z=850
	//
	// or a range to return data for all levels between and including 2 defined levels
	// i.e. z=minimum value/maximum value
	//
	// for instance if all values between and including 10m and 100m
	//
	// z=10/100
	//
	// finally a list of height values can be specified
	// i.e. z=value1,value2,value3
	//
	// for instance if values at 2m, 10m and 80m are required
	//
	// z=2,10,80
	//
	// An Arithmetic sequence using Recurring height intervals, the difference is the number of recurrences is defined at the start
	// and the amount to increment the height by is defined at the end
	//
	// i.e. z=Rn/min height/height interval
	//
	// so if the request was for 20 height levels 50m apart starting at 100m:
	//
	// z=R20/100/50
	//
	// When not specified data from all available heights SHOULD be returned
	Z *Z `form:"z,omitempty" json:"z,omitempty"`

	// Datetime Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).
	// Examples:
	// * A date-time: "2018-02-12T23:20:50Z" * A bounded interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z" * Half-bounded intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
	// Only resources that have a temporal property that intersects the value of `datetime` are selected.
	// If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
	Datetime *Datetime `form:"datetime,omitempty" json:"datetime,omitempty"`

	// ParameterName comma delimited list of parameters to retrieve data for.  Valid parameters are listed in the collections metadata
	ParameterName *ParameterName `form:"parameter-name,omitempty" json:"parameter-name,omitempty"`

	// Crs identifier (id) of the coordinate system to return data in list of valid crs identifiers for the chosen collection are defined in the metadata responses.  If not supplied the coordinate reference system will default to WGS84.
	Crs *Crs `form:"crs,omitempty" json:"crs,omitempty"`

	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// GetRequirementsClassesParams defines parameters for GetRequirementsClasses.
type GetRequirementsClassesParams struct {
	// F format to return the data response in
	F *F `form:"f,omitempty" json:"f,omitempty"`
}

// AsExtentSpatialBbox0 returns the union data inside the Extent_Spatial_Bbox_Item as a ExtentSpatialBbox0
func (t Extent_Spatial_Bbox_Item) AsExtentSpatialBbox0() (ExtentSpatialBbox0, error) {
	var body ExtentSpatialBbox0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtentSpatialBbox0 overwrites any union data inside the Extent_Spatial_Bbox_Item as the provided ExtentSpatialBbox0
func (t *Extent_Spatial_Bbox_Item) FromExtentSpatialBbox0(v ExtentSpatialBbox0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtentSpatialBbox0 performs a merge with any union data inside the Extent_Spatial_Bbox_Item, using the provided ExtentSpatialBbox0
func (t *Extent_Spatial_Bbox_Item) MergeExtentSpatialBbox0(v ExtentSpatialBbox0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExtentSpatialBbox1 returns the union data inside the Extent_Spatial_Bbox_Item as a ExtentSpatialBbox1
func (t Extent_Spatial_Bbox_Item) AsExtentSpatialBbox1() (ExtentSpatialBbox1, error) {
	var body ExtentSpatialBbox1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtentSpatialBbox1 overwrites any union data inside the Extent_Spatial_Bbox_Item as the provided ExtentSpatialBbox1
func (t *Extent_Spatial_Bbox_Item) FromExtentSpatialBbox1(v ExtentSpatialBbox1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtentSpatialBbox1 performs a merge with any union data inside the Extent_Spatial_Bbox_Item, using the provided ExtentSpatialBbox1
func (t *Extent_Spatial_Bbox_Item) MergeExtentSpatialBbox1(v ExtentSpatialBbox1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Extent_Spatial_Bbox_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Extent_Spatial_Bbox_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPointGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a PointGeoJSON
func (t FeatureGeoJSON_Geometry) AsPointGeoJSON() (PointGeoJSON, error) {
	var body PointGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided PointGeoJSON
func (t *FeatureGeoJSON_Geometry) FromPointGeoJSON(v PointGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided PointGeoJSON
func (t *FeatureGeoJSON_Geometry) MergePointGeoJSON(v PointGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipointGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a MultipointGeoJSON
func (t FeatureGeoJSON_Geometry) AsMultipointGeoJSON() (MultipointGeoJSON, error) {
	var body MultipointGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipointGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided MultipointGeoJSON
func (t *FeatureGeoJSON_Geometry) FromMultipointGeoJSON(v MultipointGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipointGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided MultipointGeoJSON
func (t *FeatureGeoJSON_Geometry) MergeMultipointGeoJSON(v MultipointGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinestringGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a LinestringGeoJSON
func (t FeatureGeoJSON_Geometry) AsLinestringGeoJSON() (LinestringGeoJSON, error) {
	var body LinestringGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinestringGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided LinestringGeoJSON
func (t *FeatureGeoJSON_Geometry) FromLinestringGeoJSON(v LinestringGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinestringGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided LinestringGeoJSON
func (t *FeatureGeoJSON_Geometry) MergeLinestringGeoJSON(v LinestringGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultilinestringGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a MultilinestringGeoJSON
func (t FeatureGeoJSON_Geometry) AsMultilinestringGeoJSON() (MultilinestringGeoJSON, error) {
	var body MultilinestringGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultilinestringGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided MultilinestringGeoJSON
func (t *FeatureGeoJSON_Geometry) FromMultilinestringGeoJSON(v MultilinestringGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultilinestringGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided MultilinestringGeoJSON
func (t *FeatureGeoJSON_Geometry) MergeMultilinestringGeoJSON(v MultilinestringGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolygonGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a PolygonGeoJSON
func (t FeatureGeoJSON_Geometry) AsPolygonGeoJSON() (PolygonGeoJSON, error) {
	var body PolygonGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolygonGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided PolygonGeoJSON
func (t *FeatureGeoJSON_Geometry) FromPolygonGeoJSON(v PolygonGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolygonGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided PolygonGeoJSON
func (t *FeatureGeoJSON_Geometry) MergePolygonGeoJSON(v PolygonGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipolygonGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a MultipolygonGeoJSON
func (t FeatureGeoJSON_Geometry) AsMultipolygonGeoJSON() (MultipolygonGeoJSON, error) {
	var body MultipolygonGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipolygonGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided MultipolygonGeoJSON
func (t *FeatureGeoJSON_Geometry) FromMultipolygonGeoJSON(v MultipolygonGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipolygonGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided MultipolygonGeoJSON
func (t *FeatureGeoJSON_Geometry) MergeMultipolygonGeoJSON(v MultipolygonGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeometrycollectionGeoJSON returns the union data inside the FeatureGeoJSON_Geometry as a GeometrycollectionGeoJSON
func (t FeatureGeoJSON_Geometry) AsGeometrycollectionGeoJSON() (GeometrycollectionGeoJSON, error) {
	var body GeometrycollectionGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeometrycollectionGeoJSON overwrites any union data inside the FeatureGeoJSON_Geometry as the provided GeometrycollectionGeoJSON
func (t *FeatureGeoJSON_Geometry) FromGeometrycollectionGeoJSON(v GeometrycollectionGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeometrycollectionGeoJSON performs a merge with any union data inside the FeatureGeoJSON_Geometry, using the provided GeometrycollectionGeoJSON
func (t *FeatureGeoJSON_Geometry) MergeGeometrycollectionGeoJSON(v GeometrycollectionGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FeatureGeoJSON_Geometry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FeatureGeoJSON_Geometry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFeatureGeoJSONId0 returns the union data inside the FeatureGeoJSON_Id as a FeatureGeoJSONId0
func (t FeatureGeoJSON_Id) AsFeatureGeoJSONId0() (FeatureGeoJSONId0, error) {
	var body FeatureGeoJSONId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureGeoJSONId0 overwrites any union data inside the FeatureGeoJSON_Id as the provided FeatureGeoJSONId0
func (t *FeatureGeoJSON_Id) FromFeatureGeoJSONId0(v FeatureGeoJSONId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureGeoJSONId0 performs a merge with any union data inside the FeatureGeoJSON_Id, using the provided FeatureGeoJSONId0
func (t *FeatureGeoJSON_Id) MergeFeatureGeoJSONId0(v FeatureGeoJSONId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureGeoJSONId1 returns the union data inside the FeatureGeoJSON_Id as a FeatureGeoJSONId1
func (t FeatureGeoJSON_Id) AsFeatureGeoJSONId1() (FeatureGeoJSONId1, error) {
	var body FeatureGeoJSONId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureGeoJSONId1 overwrites any union data inside the FeatureGeoJSON_Id as the provided FeatureGeoJSONId1
func (t *FeatureGeoJSON_Id) FromFeatureGeoJSONId1(v FeatureGeoJSONId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureGeoJSONId1 performs a merge with any union data inside the FeatureGeoJSON_Id, using the provided FeatureGeoJSONId1
func (t *FeatureGeoJSON_Id) MergeFeatureGeoJSONId1(v FeatureGeoJSONId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FeatureGeoJSON_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FeatureGeoJSON_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPointGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a PointGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsPointGeoJSON() (PointGeoJSON, error) {
	var body PointGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided PointGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromPointGeoJSON(v PointGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided PointGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergePointGeoJSON(v PointGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipointGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a MultipointGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsMultipointGeoJSON() (MultipointGeoJSON, error) {
	var body MultipointGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipointGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided MultipointGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromMultipointGeoJSON(v MultipointGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipointGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided MultipointGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergeMultipointGeoJSON(v MultipointGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinestringGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a LinestringGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsLinestringGeoJSON() (LinestringGeoJSON, error) {
	var body LinestringGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinestringGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided LinestringGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromLinestringGeoJSON(v LinestringGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinestringGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided LinestringGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergeLinestringGeoJSON(v LinestringGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultilinestringGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a MultilinestringGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsMultilinestringGeoJSON() (MultilinestringGeoJSON, error) {
	var body MultilinestringGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultilinestringGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided MultilinestringGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromMultilinestringGeoJSON(v MultilinestringGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultilinestringGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided MultilinestringGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergeMultilinestringGeoJSON(v MultilinestringGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolygonGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a PolygonGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsPolygonGeoJSON() (PolygonGeoJSON, error) {
	var body PolygonGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolygonGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided PolygonGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromPolygonGeoJSON(v PolygonGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolygonGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided PolygonGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergePolygonGeoJSON(v PolygonGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipolygonGeoJSON returns the union data inside the GeometrycollectionGeoJSON_Geometries_Item as a MultipolygonGeoJSON
func (t GeometrycollectionGeoJSON_Geometries_Item) AsMultipolygonGeoJSON() (MultipolygonGeoJSON, error) {
	var body MultipolygonGeoJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipolygonGeoJSON overwrites any union data inside the GeometrycollectionGeoJSON_Geometries_Item as the provided MultipolygonGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) FromMultipolygonGeoJSON(v MultipolygonGeoJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipolygonGeoJSON performs a merge with any union data inside the GeometrycollectionGeoJSON_Geometries_Item, using the provided MultipolygonGeoJSON
func (t *GeometrycollectionGeoJSON_Geometries_Item) MergeMultipolygonGeoJSON(v MultipolygonGeoJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GeometrycollectionGeoJSON_Geometries_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GeometrycollectionGeoJSON_Geometries_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsObservedPropertyCollectionCategoriesDescription0 returns the union data inside the ObservedPropertyCollection_Categories_Description as a ObservedPropertyCollectionCategoriesDescription0
func (t ObservedPropertyCollection_Categories_Description) AsObservedPropertyCollectionCategoriesDescription0() (ObservedPropertyCollectionCategoriesDescription0, error) {
	var body ObservedPropertyCollectionCategoriesDescription0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionCategoriesDescription0 overwrites any union data inside the ObservedPropertyCollection_Categories_Description as the provided ObservedPropertyCollectionCategoriesDescription0
func (t *ObservedPropertyCollection_Categories_Description) FromObservedPropertyCollectionCategoriesDescription0(v ObservedPropertyCollectionCategoriesDescription0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionCategoriesDescription0 performs a merge with any union data inside the ObservedPropertyCollection_Categories_Description, using the provided ObservedPropertyCollectionCategoriesDescription0
func (t *ObservedPropertyCollection_Categories_Description) MergeObservedPropertyCollectionCategoriesDescription0(v ObservedPropertyCollectionCategoriesDescription0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObservedPropertyCollectionCategoriesDescription1 returns the union data inside the ObservedPropertyCollection_Categories_Description as a ObservedPropertyCollectionCategoriesDescription1
func (t ObservedPropertyCollection_Categories_Description) AsObservedPropertyCollectionCategoriesDescription1() (ObservedPropertyCollectionCategoriesDescription1, error) {
	var body ObservedPropertyCollectionCategoriesDescription1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionCategoriesDescription1 overwrites any union data inside the ObservedPropertyCollection_Categories_Description as the provided ObservedPropertyCollectionCategoriesDescription1
func (t *ObservedPropertyCollection_Categories_Description) FromObservedPropertyCollectionCategoriesDescription1(v ObservedPropertyCollectionCategoriesDescription1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionCategoriesDescription1 performs a merge with any union data inside the ObservedPropertyCollection_Categories_Description, using the provided ObservedPropertyCollectionCategoriesDescription1
func (t *ObservedPropertyCollection_Categories_Description) MergeObservedPropertyCollectionCategoriesDescription1(v ObservedPropertyCollectionCategoriesDescription1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ObservedPropertyCollection_Categories_Description) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ObservedPropertyCollection_Categories_Description) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsObservedPropertyCollectionCategoriesLabel0 returns the union data inside the ObservedPropertyCollection_Categories_Label as a ObservedPropertyCollectionCategoriesLabel0
func (t ObservedPropertyCollection_Categories_Label) AsObservedPropertyCollectionCategoriesLabel0() (ObservedPropertyCollectionCategoriesLabel0, error) {
	var body ObservedPropertyCollectionCategoriesLabel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionCategoriesLabel0 overwrites any union data inside the ObservedPropertyCollection_Categories_Label as the provided ObservedPropertyCollectionCategoriesLabel0
func (t *ObservedPropertyCollection_Categories_Label) FromObservedPropertyCollectionCategoriesLabel0(v ObservedPropertyCollectionCategoriesLabel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionCategoriesLabel0 performs a merge with any union data inside the ObservedPropertyCollection_Categories_Label, using the provided ObservedPropertyCollectionCategoriesLabel0
func (t *ObservedPropertyCollection_Categories_Label) MergeObservedPropertyCollectionCategoriesLabel0(v ObservedPropertyCollectionCategoriesLabel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObservedPropertyCollectionCategoriesLabel1 returns the union data inside the ObservedPropertyCollection_Categories_Label as a ObservedPropertyCollectionCategoriesLabel1
func (t ObservedPropertyCollection_Categories_Label) AsObservedPropertyCollectionCategoriesLabel1() (ObservedPropertyCollectionCategoriesLabel1, error) {
	var body ObservedPropertyCollectionCategoriesLabel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionCategoriesLabel1 overwrites any union data inside the ObservedPropertyCollection_Categories_Label as the provided ObservedPropertyCollectionCategoriesLabel1
func (t *ObservedPropertyCollection_Categories_Label) FromObservedPropertyCollectionCategoriesLabel1(v ObservedPropertyCollectionCategoriesLabel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionCategoriesLabel1 performs a merge with any union data inside the ObservedPropertyCollection_Categories_Label, using the provided ObservedPropertyCollectionCategoriesLabel1
func (t *ObservedPropertyCollection_Categories_Label) MergeObservedPropertyCollectionCategoriesLabel1(v ObservedPropertyCollectionCategoriesLabel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ObservedPropertyCollection_Categories_Label) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ObservedPropertyCollection_Categories_Label) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsObservedPropertyCollectionLabel0 returns the union data inside the ObservedPropertyCollection_Label as a ObservedPropertyCollectionLabel0
func (t ObservedPropertyCollection_Label) AsObservedPropertyCollectionLabel0() (ObservedPropertyCollectionLabel0, error) {
	var body ObservedPropertyCollectionLabel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionLabel0 overwrites any union data inside the ObservedPropertyCollection_Label as the provided ObservedPropertyCollectionLabel0
func (t *ObservedPropertyCollection_Label) FromObservedPropertyCollectionLabel0(v ObservedPropertyCollectionLabel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionLabel0 performs a merge with any union data inside the ObservedPropertyCollection_Label, using the provided ObservedPropertyCollectionLabel0
func (t *ObservedPropertyCollection_Label) MergeObservedPropertyCollectionLabel0(v ObservedPropertyCollectionLabel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObservedPropertyCollectionLabel1 returns the union data inside the ObservedPropertyCollection_Label as a ObservedPropertyCollectionLabel1
func (t ObservedPropertyCollection_Label) AsObservedPropertyCollectionLabel1() (ObservedPropertyCollectionLabel1, error) {
	var body ObservedPropertyCollectionLabel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObservedPropertyCollectionLabel1 overwrites any union data inside the ObservedPropertyCollection_Label as the provided ObservedPropertyCollectionLabel1
func (t *ObservedPropertyCollection_Label) FromObservedPropertyCollectionLabel1(v ObservedPropertyCollectionLabel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObservedPropertyCollectionLabel1 performs a merge with any union data inside the ObservedPropertyCollection_Label, using the provided ObservedPropertyCollectionLabel1
func (t *ObservedPropertyCollection_Label) MergeObservedPropertyCollectionLabel1(v ObservedPropertyCollectionLabel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ObservedPropertyCollection_Label) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ObservedPropertyCollection_Label) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParameterCategoryEncoding0 returns the union data inside the Parameter_CategoryEncoding_AdditionalProperties as a ParameterCategoryEncoding0
func (t Parameter_CategoryEncoding_AdditionalProperties) AsParameterCategoryEncoding0() (ParameterCategoryEncoding0, error) {
	var body ParameterCategoryEncoding0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParameterCategoryEncoding0 overwrites any union data inside the Parameter_CategoryEncoding_AdditionalProperties as the provided ParameterCategoryEncoding0
func (t *Parameter_CategoryEncoding_AdditionalProperties) FromParameterCategoryEncoding0(v ParameterCategoryEncoding0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParameterCategoryEncoding0 performs a merge with any union data inside the Parameter_CategoryEncoding_AdditionalProperties, using the provided ParameterCategoryEncoding0
func (t *Parameter_CategoryEncoding_AdditionalProperties) MergeParameterCategoryEncoding0(v ParameterCategoryEncoding0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParameterCategoryEncoding1 returns the union data inside the Parameter_CategoryEncoding_AdditionalProperties as a ParameterCategoryEncoding1
func (t Parameter_CategoryEncoding_AdditionalProperties) AsParameterCategoryEncoding1() (ParameterCategoryEncoding1, error) {
	var body ParameterCategoryEncoding1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParameterCategoryEncoding1 overwrites any union data inside the Parameter_CategoryEncoding_AdditionalProperties as the provided ParameterCategoryEncoding1
func (t *Parameter_CategoryEncoding_AdditionalProperties) FromParameterCategoryEncoding1(v ParameterCategoryEncoding1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParameterCategoryEncoding1 performs a merge with any union data inside the Parameter_CategoryEncoding_AdditionalProperties, using the provided ParameterCategoryEncoding1
func (t *Parameter_CategoryEncoding_AdditionalProperties) MergeParameterCategoryEncoding1(v ParameterCategoryEncoding1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Parameter_CategoryEncoding_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Parameter_CategoryEncoding_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParameterNamesCategoryEncoding0 returns the union data inside the ParameterNames_CategoryEncoding_AdditionalProperties as a ParameterNamesCategoryEncoding0
func (t ParameterNames_CategoryEncoding_AdditionalProperties) AsParameterNamesCategoryEncoding0() (ParameterNamesCategoryEncoding0, error) {
	var body ParameterNamesCategoryEncoding0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParameterNamesCategoryEncoding0 overwrites any union data inside the ParameterNames_CategoryEncoding_AdditionalProperties as the provided ParameterNamesCategoryEncoding0
func (t *ParameterNames_CategoryEncoding_AdditionalProperties) FromParameterNamesCategoryEncoding0(v ParameterNamesCategoryEncoding0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParameterNamesCategoryEncoding0 performs a merge with any union data inside the ParameterNames_CategoryEncoding_AdditionalProperties, using the provided ParameterNamesCategoryEncoding0
func (t *ParameterNames_CategoryEncoding_AdditionalProperties) MergeParameterNamesCategoryEncoding0(v ParameterNamesCategoryEncoding0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParameterNamesCategoryEncoding1 returns the union data inside the ParameterNames_CategoryEncoding_AdditionalProperties as a ParameterNamesCategoryEncoding1
func (t ParameterNames_CategoryEncoding_AdditionalProperties) AsParameterNamesCategoryEncoding1() (ParameterNamesCategoryEncoding1, error) {
	var body ParameterNamesCategoryEncoding1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParameterNamesCategoryEncoding1 overwrites any union data inside the ParameterNames_CategoryEncoding_AdditionalProperties as the provided ParameterNamesCategoryEncoding1
func (t *ParameterNames_CategoryEncoding_AdditionalProperties) FromParameterNamesCategoryEncoding1(v ParameterNamesCategoryEncoding1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParameterNamesCategoryEncoding1 performs a merge with any union data inside the ParameterNames_CategoryEncoding_AdditionalProperties, using the provided ParameterNamesCategoryEncoding1
func (t *ParameterNames_CategoryEncoding_AdditionalProperties) MergeParameterNamesCategoryEncoding1(v ParameterNamesCategoryEncoding1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParameterNames_CategoryEncoding_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParameterNames_CategoryEncoding_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReferenceSystem0 returns the union data inside the ReferenceSystem as a ReferenceSystem0
func (t ReferenceSystem) AsReferenceSystem0() (ReferenceSystem0, error) {
	var body ReferenceSystem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceSystem0 overwrites any union data inside the ReferenceSystem as the provided ReferenceSystem0
func (t *ReferenceSystem) FromReferenceSystem0(v ReferenceSystem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceSystem0 performs a merge with any union data inside the ReferenceSystem, using the provided ReferenceSystem0
func (t *ReferenceSystem) MergeReferenceSystem0(v ReferenceSystem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReferenceSystem1 returns the union data inside the ReferenceSystem as a ReferenceSystem1
func (t ReferenceSystem) AsReferenceSystem1() (ReferenceSystem1, error) {
	var body ReferenceSystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceSystem1 overwrites any union data inside the ReferenceSystem as the provided ReferenceSystem1
func (t *ReferenceSystem) FromReferenceSystem1(v ReferenceSystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceSystem1 performs a merge with any union data inside the ReferenceSystem, using the provided ReferenceSystem1
func (t *ReferenceSystem) MergeReferenceSystem1(v ReferenceSystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReferenceSystem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ReferenceSystem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsN0 returns the union data inside the Bbox as a N0
func (t Bbox) AsN0() (N0, error) {
	var body N0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromN0 overwrites any union data inside the Bbox as the provided N0
func (t *Bbox) FromN0(v N0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeN0 performs a merge with any union data inside the Bbox, using the provided N0
func (t *Bbox) MergeN0(v N0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsN1 returns the union data inside the Bbox as a N1
func (t Bbox) AsN1() (N1, error) {
	var body N1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromN1 overwrites any union data inside the Bbox as the provided N1
func (t *Bbox) FromN1(v N1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeN1 performs a merge with any union data inside the Bbox, using the provided N1
func (t *Bbox) MergeN1(v N1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Bbox) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Bbox) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// landing page of this API
	// (GET /)
	GetLandingPage(ctx echo.Context, params GetLandingPageParams) error
	// List the avialable collections from the service
	// (GET /collections)
	ListCollections(ctx echo.Context, params ListCollectionsParams) error
	// List query types supported by the collection
	// (GET /collections/{collectionId})
	GetQueries(ctx echo.Context, collectionId CollectionId, params GetQueriesParams) error
	// List data instances of {collectionId}
	// (GET /collections/{collectionId}/instances)
	GetCollectionInstances(ctx echo.Context, collectionId CollectionId, params GetCollectionInstancesParams) error
	// Query end point for position queries of instance {instanceId} of collection {collectionId}
	// (GET /collections/{collectionId}/instances/{instanceId}/position)
	GetInstanceDataForPoint(ctx echo.Context, collectionId CollectionId, instanceId InstanceId, params GetInstanceDataForPointParams) error
	// Query end point for position queries  of collection {collectionId}
	// (GET /collections/{collectionId}/position)
	GetDataForPoint(ctx echo.Context, collectionId CollectionId, params GetDataForPointParams) error
	// Information about standards that this API conforms to
	// (GET /conformance)
	GetRequirementsClasses(ctx echo.Context, params GetRequirementsClassesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetLandingPage converts echo context to params.
func (w *ServerInterfaceWrapper) GetLandingPage(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLandingPageParams
	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLandingPage(ctx, params)
	return err
}

// ListCollections converts echo context to params.
func (w *ServerInterfaceWrapper) ListCollections(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCollectionsParams
	// ------------- Optional query parameter "bbox" -------------

	err = runtime.BindQueryParameter("form", false, false, "bbox", ctx.QueryParams(), &params.Bbox)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bbox: %s", err))
	}

	// ------------- Optional query parameter "datetime" -------------

	err = runtime.BindQueryParameter("form", false, false, "datetime", ctx.QueryParams(), &params.Datetime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datetime: %s", err))
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCollections(ctx, params)
	return err
}

// GetQueries converts echo context to params.
func (w *ServerInterfaceWrapper) GetQueries(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collectionId" -------------
	var collectionId CollectionId

	err = runtime.BindStyledParameterWithOptions("simple", "collectionId", ctx.Param("collectionId"), &collectionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collectionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQueriesParams
	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQueries(ctx, collectionId, params)
	return err
}

// GetCollectionInstances converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionInstances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collectionId" -------------
	var collectionId CollectionId

	err = runtime.BindStyledParameterWithOptions("simple", "collectionId", ctx.Param("collectionId"), &collectionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collectionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionInstancesParams
	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectionInstances(ctx, collectionId, params)
	return err
}

// GetInstanceDataForPoint converts echo context to params.
func (w *ServerInterfaceWrapper) GetInstanceDataForPoint(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collectionId" -------------
	var collectionId CollectionId

	err = runtime.BindStyledParameterWithOptions("simple", "collectionId", ctx.Param("collectionId"), &collectionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collectionId: %s", err))
	}

	// ------------- Path parameter "instanceId" -------------
	var instanceId InstanceId

	err = runtime.BindStyledParameterWithOptions("simple", "instanceId", ctx.Param("instanceId"), &instanceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter instanceId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInstanceDataForPointParams
	// ------------- Required query parameter "coords" -------------

	err = runtime.BindQueryParameter("form", true, true, "coords", ctx.QueryParams(), &params.Coords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter coords: %s", err))
	}

	// ------------- Optional query parameter "z" -------------

	err = runtime.BindQueryParameter("form", false, false, "z", ctx.QueryParams(), &params.Z)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter z: %s", err))
	}

	// ------------- Optional query parameter "datetime" -------------

	err = runtime.BindQueryParameter("form", false, false, "datetime", ctx.QueryParams(), &params.Datetime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datetime: %s", err))
	}

	// ------------- Optional query parameter "parameter-name" -------------

	err = runtime.BindQueryParameter("form", false, false, "parameter-name", ctx.QueryParams(), &params.ParameterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parameter-name: %s", err))
	}

	// ------------- Optional query parameter "crs" -------------

	err = runtime.BindQueryParameter("form", true, false, "crs", ctx.QueryParams(), &params.Crs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter crs: %s", err))
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInstanceDataForPoint(ctx, collectionId, instanceId, params)
	return err
}

// GetDataForPoint converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataForPoint(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collectionId" -------------
	var collectionId CollectionId

	err = runtime.BindStyledParameterWithOptions("simple", "collectionId", ctx.Param("collectionId"), &collectionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collectionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataForPointParams
	// ------------- Required query parameter "coords" -------------

	err = runtime.BindQueryParameter("form", true, true, "coords", ctx.QueryParams(), &params.Coords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter coords: %s", err))
	}

	// ------------- Optional query parameter "z" -------------

	err = runtime.BindQueryParameter("form", false, false, "z", ctx.QueryParams(), &params.Z)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter z: %s", err))
	}

	// ------------- Optional query parameter "datetime" -------------

	err = runtime.BindQueryParameter("form", false, false, "datetime", ctx.QueryParams(), &params.Datetime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datetime: %s", err))
	}

	// ------------- Optional query parameter "parameter-name" -------------

	err = runtime.BindQueryParameter("form", false, false, "parameter-name", ctx.QueryParams(), &params.ParameterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parameter-name: %s", err))
	}

	// ------------- Optional query parameter "crs" -------------

	err = runtime.BindQueryParameter("form", true, false, "crs", ctx.QueryParams(), &params.Crs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter crs: %s", err))
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDataForPoint(ctx, collectionId, params)
	return err
}

// GetRequirementsClasses converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequirementsClasses(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRequirementsClassesParams
	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", ctx.QueryParams(), &params.F)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter f: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequirementsClasses(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetLandingPage)
	router.GET(baseURL+"/collections", wrapper.ListCollections)
	router.GET(baseURL+"/collections/:collectionId", wrapper.GetQueries)
	router.GET(baseURL+"/collections/:collectionId/instances", wrapper.GetCollectionInstances)
	router.GET(baseURL+"/collections/:collectionId/instances/:instanceId/position", wrapper.GetInstanceDataForPoint)
	router.GET(baseURL+"/collections/:collectionId/position", wrapper.GetDataForPoint)
	router.GET(baseURL+"/conformance", wrapper.GetRequirementsClasses)

}
